package main

import (
	"context"
	"encoding/base64"
	"net/http"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"github.com/chromedp/chromedp"
	"github.com/go-chi/chi/v5"
)

func registerRoutes(r chi.Router) {
	r.Get("/capture", handleCapture)
	r.Get("/status", handleStatus)
}

func handleCapture(w http.ResponseWriter, r *http.Request) {
	targetURL := strings.TrimSpace(r.URL.Query().Get("url"))
	if targetURL == "" {
		writeError(w, http.StatusBadRequest, "url parameter is required")
		return
	}

	width := 1280
	if v := r.URL.Query().Get("width"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n >= 1 && n <= 7680 {
			width = n
		}
	}

	height := 720
	if v := r.URL.Query().Get("height"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n >= 1 && n <= 4320 {
			height = n
		}
	}

	fullPage := false
	if v := r.URL.Query().Get("full_page"); v == "true" || v == "1" {
		fullPage = true
	}

	format := "png"
	if v := strings.ToLower(r.URL.Query().Get("format")); v == "jpeg" || v == "jpg" {
		format = "jpeg"
	}

	quality := 90
	if v := r.URL.Query().Get("quality"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n >= 1 && n <= 100 {
			quality = n
		}
	}

	// Set up chromedp allocator with headless options
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", true),
		chromedp.Flag("no-sandbox", true),
		chromedp.Flag("disable-gpu", true),
		chromedp.Flag("disable-software-rasterizer", true),
	)

	allocCtx, allocCancel := chromedp.NewExecAllocator(context.Background(), opts...)
	defer allocCancel()

	ctx, cancel := chromedp.NewContext(allocCtx)
	defer cancel()

	// Set a timeout for the entire operation
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	var buf []byte

	// Build action list
	actions := []chromedp.Action{
		chromedp.EmulateViewport(int64(width), int64(height)),
		chromedp.Navigate(targetURL),
		chromedp.WaitReady("body"),
	}

	if fullPage {
		// FullScreenshot captures the entire scrollable page
		actions = append(actions, chromedp.FullScreenshot(&buf, quality))
	} else {
		if format == "jpeg" {
			// For JPEG viewport screenshots, use FullScreenshot with viewport dimensions
			// since CaptureScreenshot only produces PNG
			actions = append(actions, chromedp.FullScreenshot(&buf, quality))
		} else {
			// PNG viewport screenshot
			actions = append(actions, chromedp.CaptureScreenshot(&buf))
		}
	}

	if err := chromedp.Run(ctx, actions...); err != nil {
		writeError(w, http.StatusInternalServerError, "screenshot failed: "+err.Error())
		return
	}

	encoded := base64.StdEncoding.EncodeToString(buf)

	writeJSON(w, http.StatusOK, map[string]interface{}{
		"url":          targetURL,
		"width":        width,
		"height":       height,
		"format":       format,
		"size_bytes":   len(buf),
		"image_base64": encoded,
	})
}

func handleStatus(w http.ResponseWriter, r *http.Request) {
	// Try to find Chrome/Chromium binary
	chromePath := findChromePath()

	available := chromePath != ""

	writeJSON(w, http.StatusOK, map[string]interface{}{
		"available":   available,
		"chrome_path": chromePath,
	})
}

func findChromePath() string {
	// Check common Chrome/Chromium paths
	candidates := []string{
		"google-chrome",
		"google-chrome-stable",
		"chromium",
		"chromium-browser",
		"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
		"/usr/bin/google-chrome",
		"/usr/bin/chromium",
		"/usr/bin/chromium-browser",
		"/snap/bin/chromium",
	}

	for _, candidate := range candidates {
		if path, err := exec.LookPath(candidate); err == nil {
			return path
		}
		// For absolute paths, check directly
		if strings.HasPrefix(candidate, "/") {
			if _, err := exec.LookPath(candidate); err == nil {
				return candidate
			}
		}
	}

	return ""
}
